<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Copying and distribution of this file, with or without modification,
     are permitted in any medium without royalty provided the copyright
     notice and this notice are preserved.  This file is offered as-is,
     without any warranty.
-->

<!-- Note: This file not compatible with IrMaster! -->

<!--

Author: Bengt Martensson

-->
<exportformats xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns="http://www.harctoolbox.org/exportformats"
               xmlns:xi="http://www.w3.org/2001/XInclude"
               xsi:schemaLocation="http://www.harctoolbox.org/exportformats http://www.harctoolbox.org/schemas/exportformats.xsd">

    <exportformat name="GirrX" extension=".girr" multiSignal="true" simpleSequence="false" url="http://www.harctoolbox.org/Girr.html">
        <documentation>A style sheet can be selected to be linked in into the exported Girr file.
            The type of style file (presently xslt and css) can also be selected.

            "Fat form raw" can be selected; this means that the raw signals are not given as a text string of
            alternating positive and negative numbers, but the  individual flashes and gaps are enclosed into own XML elements.
            This can be  advantageous if generating XML mainly for the purpose of transforming to other formats.</documentation>
        <options>
            <option name="stylesheetUrl" displayName="Stylesheet URL" title="URL of stylesheet linked contained in the file">
                <text default="simplehtml.xsl"/>
            </option>
            <option name="schemaLink" displayName="Schema link" title="If selected, the schema reference is contained in the generated file">
                <boolean default="true"/>
            </option>
            <option name="fatFormRaw" displayName="Fat form raw" title="If selected, the raw signals are not given a
s a text string of alternating positive and negative numbers, but the  individual flashes and gaps are enclosed into own XML elements.">
                <boolean default="false"/>
            </option>
            <option name="stylesheetType" displayName="Stylesheet type">
                <selection>
                    <value text="xslt" default="true"/>
                    <value text="css"/>
                </selection>
            </option>
        </options>
    </exportformat>

<exportformat name="irplus" extension="irplus" multiSignal="true" simpleSequence="false" url="https://irplus-remote.github.io/">
    <documentation>IrPlus is an Android app.</documentation>
    <options>
        <option name="repeats" displayName="Number of repeats" title="Number of times to send each signal">
            <selection>
                <value text="1"  default="true"/>
                <value text="2"/>
                <value text="3"/>
                <value text="4"/>
                <value text="5"/>
                <value text="10"/>
            </selection>
        </option>
        <option name="columns" title="Number of columns in layout">
            <selection>
                <value text="1"/>
                <value text="2"/>
                <value text="3"  default="true"/>
                <value text="4"/>
                <value text="5"/>
                <value text="10"/>
            </selection>
        </option>
    </options>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="xml" indent="yes" omit-xml-declaration="yes"/>

    <xsl:template match="/remotes">
        <irplus>
            <xsl:comment>This file was automatically generated by IrScrutinizer</xsl:comment>
            <xsl:apply-templates select="remote"/>
        </irplus>
    </xsl:template>

    <xsl:template match="remote">
        <device>
            <xsl:attribute name="manufacturer">
                <xsl:value-of select="@manufacturer"/>
                <xsl:if test="not(@manufacturer)">unknown manufacturer</xsl:if>
            </xsl:attribute>
            <xsl:attribute name="model">
                <xsl:value-of select="@model"/>
                <xsl:if test="not(@model)">unknown model</xsl:if>
            </xsl:attribute>
            <xsl:attribute name="format">PRONTO_HEX</xsl:attribute>
            <!--xsl:attribute name="columns">3</xsl:attribute--> <!-- uncomment if desired -->
            <xsl:apply-templates select="commandSet/command"/>
        </device>
    </xsl:template>

    <xsl:template match="command">
        <button>
            <xsl:attribute name="label">
                <xsl:value-of select="@name"/>
            </xsl:attribute>
            <xsl:value-of select="ccf"/>
        </button>
    </xsl:template>
</xsl:stylesheet>

</exportformat>

<exportformat name="RemoteMaster" extension="rmdu" multiSignal="true" simpleSequence="false"
              url="http://www.hifi-remote.com/wiki/index.php?title=Remote_Master_Manual">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:java="http://xml.apache.org/xalan/java" version="1.0">
    <xsl:output method="text" />

    <xsl:template match="/">
        <xsl:apply-templates select="remotes/remote[position()=1]"/> <!-- just consider the first remote -->
    </xsl:template>

    <xsl:template match="remote">
        <xsl:text># This file was created by IrScrutinizer.
# It is not directly usable in RemoteMaster. For this, make sure that
# protocols.ini contains the "protocol" ImportOnly. Also, check
# Options -> "Allow preserve Control", and then select
# "Preserve: OBC and function parameters" on the "Setup" pane.
# Then open this file with RemoteMaster, and select a sensible executor
# (called protocol in RemoteMaster).
#
# Original protocol: </xsl:text>
        <xsl:value-of select="commandSet[position()=1]//parameters/@protocol"/>
        <xsl:text>
#
Description=</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
Notes=</xsl:text>
        <xsl:value-of select="@comment"/>
        <xsl:text>\n\nOriginal protocol: </xsl:text>
        <xsl:value-of select="commandSet[position()=1]//parameters/@protocol"/>
        <xsl:text>
Remote.name=URC-7781 One For All Digital 12
Remote.signature=11311131
DeviceType=Cable
DeviceIndex=3
SetupCode=1999
Protocol=99 99
Protocol.name=ImportOnly
ProtocolParms=</xsl:text>
        <xsl:value-of select="commandSet[position()=1]/command[position()=1]/parameters/parameter[@name='D']/@value"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="commandSet[position()=1]/command[position()=1]/parameters/parameter[@name='S']/@value"/>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="commandSet/command"/>
    </xsl:template>

    <xsl:template match="command">
        <xsl:text>Function.</xsl:text>
        <xsl:value-of select="position() - 1"/>
        <xsl:text>.name=</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
Function.</xsl:text>
        <xsl:value-of select="position() - 1"/>
        <xsl:text>.hex=</xsl:text>
        <xsl:value-of select="java:java.lang.Integer.toHexString(number(parameters/parameter[@name='F']/@value))"/>
        <xsl:apply-templates select="@comment"/>
        <xsl:text>
</xsl:text>

    </xsl:template>

    <xsl:template match="@comment">
        <xsl:text>
Function.</xsl:text>
        <xsl:value-of select="count(../preceding-sibling::command)"/>
        <xsl:text>.notes=</xsl:text>
        <xsl:value-of select="."/>
    </xsl:template>
</xsl:stylesheet>
</exportformat>

<exportformat name="Arduino Raw" extension="ino" multiSignal="true" simpleSequence="false">
<!-- Limitations:supports only one remote (ignores all but the first one),
     Does not support ending sequences (ignores them).
     Does not (yet) guarantee that the generated C identifiers will be unique.
    -->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:java="http://xml.apache.org/xalan/java"
                xmlns:cidentifierfactory="http://xml.apache.org/xalan/java/org.harctoolbox.irscrutinizer.exporter.CIdentifierFactory"
                version="1.0">
    <xsl:output method="text" />
    <xsl:variable name="cIdentifierFactory" select="cidentifierfactory:new()"/>

    <xsl:template match="/">
        <xsl:text><![CDATA[// This Arduino sketch was automatically generated by IrScrutinizer.

// It supports:
//
// * IRremote https://github.com/z3t0/Arduino-IRremote
//            http://z3t0.github.io/Arduino-IRremote/
// * IRLib    https://github.com/cyborg5/IRLib
// * Infrared4Arduino https://github.com/bengtmartensson/Infrared4Arduino,
//                    http://www.harctoolbox.org/Infrared4Arduino.html (planned)

// For problems, bugs, and suggestions, please open an issue at
// https://github.com/bengtmartensson/harctoolboxbundle/issues

// This file contains C identifiers that has been translated from command names.
// They are not guaranteed to be unique.

// Define exactly one of these
// #define IRREMOTE
// #define IRLIB
#define INFRARED4ARDUINO

/////////////////////////////////////////////////////
// Sanity check
#if defined(IRREMOTE) & ( defined(IRLIB) | defined(INFRARED4ARDUINO) )
#error Must define only one of IRREMOTE, IRLIB, or INFRARED4ARDUINO
#endif

#if defined(IRLIB) & ( defined(IRREMOTE) | defined(INFRARED4ARDUINO) )
#error Must define only one of IRREMOTE, IRLIB, or INFRARED4ARDUINO
#endif

#if defined(INFRARED4ARDUINO) & ( defined(IRLIB) | defined(IRREMOTE) )
#error Must define only one of IRREMOTE, IRLIB, or INFRARED4ARDUINO
#endif

#ifdef IRREMOTE
#include <IRremote.h>
#elif defined(IRLIB)
#include <IRLib.h>
#define sendRaw send
#elif defined(INFRARED4ARDUINO)
#include <IrSenderPwm.h>
#else
#error Must defined one of IRREMOTE, IRLIB, or INFRARED4ARDUINO
#endif

#if defined(IRREMOTE) | defined(IRLIB)
typedef uint16_t microseconds_t; // Change if desired
typedef uint16_t frequency_t;    // Change if desired

static inline unsigned hz2khz(frequency_t f) { return f/1000; }
#endif

// Constants
static const long BAUD=115200;

// Global variables
#ifdef IRREMOTE
IRsend irsend;
#elif defined(IRLIB)
IRsendRaw irsend;
#else
IrSender *irsend = IrSenderPwm::getInstance(true);
#endif


]]></xsl:text>
<xsl:apply-templates select="remotes/remote[position()=1]//command" mode="definition"/>

<xsl:text><![CDATA[
static void sendRaw(const microseconds_t intro_P[], size_t lengthIntro, const microseconds_t repeat_P[],
             size_t lengthRepeat, frequency_t frequency, unsigned times) {
    microseconds_t intro[lengthIntro];
    microseconds_t repeat[lengthRepeat];
    memcpy_PF(intro, (uint_farptr_t) intro_P, sizeof(microseconds_t) * lengthIntro);
    memcpy_PF(repeat, (uint_farptr_t) repeat_P, sizeof(microseconds_t) * lengthRepeat);

#if defined(IRREMOTE) | defined(IRLIB)
    if (lengthIntro > 0)
        irsend.sendRaw(intro, lengthIntro, hz2khz(frequency));
    if (lengthRepeat > 0)
        for (unsigned i = 0; i < times - (lengthIntro > 0); i++)
            irsend.sendRaw(repeat, lengthRepeat, hz2khz(frequency));
#else // INFRARED4ARDUINO
    IrSignal irSignal(intro, lengthIntro, repeat, lengthRepeat, NULL, 0, frequency);
    irsend->sendIrSignal(irSignal, times);
#endif
}

void setup() {
    Serial.begin(BAUD);
    Serial.setTimeout(60000L);
}

// A pretty silly main loop; intended to serve as an example.
void loop() {
    Serial.println(F("Enter number of signal to send (1 .. ]]></xsl:text>
    <xsl:value-of select="count(//remote[position()=1]//command)"/>
    <xsl:text>)"));
    long commandno = Serial.parseInt();
    Serial.println(F("Enter number of times to send it"));
    long times = Serial.parseInt();
    switch (commandno) {
</xsl:text>
        <xsl:apply-templates select="//remote[position()=1]" mode="using"/>
        <xsl:text>    default:
        Serial.println("Invalid number entered, try again");
        break;
    }
}
</xsl:text>
    </xsl:template>

    <xsl:template match="remote" mode="using">
        <xsl:apply-templates select="//command" mode="using"/>
    </xsl:template>

    <xsl:template match="command" mode="definition">
        <xsl:text>// Command #</xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>: </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="parameters"/>
        <xsl:apply-templates select="raw" mode="definition"/>
        <!--xsl:apply-templates select="ccf"/-->
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="ccf">
        <xsl:text>const char *pronto_</xsl:text>
        <xsl:value-of select="../@name"/>
        <xsl:text> = "</xsl:text>
        <xsl:value-of select="."/>
        <xsl:text>";
</xsl:text>
    </xsl:template>

    <xsl:template match="parameters">
        <xsl:text>// Protocol: </xsl:text>
        <xsl:value-of select="@protocol"/>
        <xsl:text>, Parameters:</xsl:text>
        <xsl:apply-templates select="parameter"/>
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="parameter">
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>=</xsl:text>
        <xsl:value-of select="@value"/>
    </xsl:template>

    <xsl:template match="raw" mode="definition">
        <xsl:apply-templates select="*" mode="definition"/>
    </xsl:template>

    <xsl:template match="intro|repeat" mode="definition">
        <xsl:text>const microseconds_t </xsl:text>
        <xsl:value-of select="name(.)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="cidentifierfactory:mkCIdentifier($cIdentifierFactory, string(../../@name))"/>
        <xsl:text>[] PROGMEM = { </xsl:text>
        <xsl:apply-templates select="*"/>
        <xsl:text> };
</xsl:text>
    </xsl:template>

    <xsl:template match="flash"><xsl:value-of select="."/><xsl:text>, </xsl:text></xsl:template>
     <xsl:template match="gap"><xsl:value-of select="."/><xsl:text>, </xsl:text></xsl:template>
     <xsl:template match="gap[position()=last()]">
         <xsl:if test=". &gt; 65535">
             <xsl:text>65535</xsl:text>
         </xsl:if>
         <xsl:if test=". &lt;= 65535">
             <xsl:value-of select="."/>
         </xsl:if>
     </xsl:template>

     <xsl:template match="command" mode="using">
         <xsl:text>    case </xsl:text>
         <xsl:value-of select="position()"/>
         <xsl:text>L:
</xsl:text>
     <xsl:text>        sendRaw(</xsl:text>
         <xsl:apply-templates select="raw" mode="arg"/>
         <xsl:value-of select="raw/@frequency"/>
         <xsl:text>, times);
        break;
</xsl:text>
     </xsl:template>

     <xsl:template match="raw" mode="arg">
         <xsl:if test="not(intro)">
             <xsl:text>NULL, 0, </xsl:text>
         </xsl:if>
         <xsl:apply-templates select="*" mode="arg"/>
         <xsl:if test="not(repeat)">
             <xsl:text>NULL, 0, </xsl:text>
         </xsl:if>
     </xsl:template>

     <xsl:template match="intro|repeat" mode="arg">
         <xsl:value-of select="name(.)"/>
         <xsl:text>_</xsl:text>
         <xsl:value-of select="cidentifierfactory:mkCIdentifier($cIdentifierFactory, string(../../@name))"/>
         <xsl:text>, </xsl:text>
         <xsl:value-of select="count(*)"/>
         <xsl:text>, </xsl:text>
     </xsl:template>

     <!-- just to be on the safe side -->
     <xsl:template match="ending">
         <xsl:comment>Warning: ending sequence in command <xsl:value-of select="../../@name"/> was ignored.</xsl:comment>
     </xsl:template>

</xsl:stylesheet>
</exportformat>

<exportformat name="C" extension="c" multiSignal="true" simpleSequence="false">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />

    <xsl:template match="/remotes">
        <xsl:text>/* This file was automatically generated by IrScrutinizer */

const int frequency = </xsl:text>
<xsl:value-of select="remote/commandSet/command/raw/@frequency"/><xsl:text>;
</xsl:text>
<xsl:text>const char *protocol = "</xsl:text><xsl:value-of select="remote/commandSet/command/parameters/@protocol"/><xsl:text>";
</xsl:text>
<xsl:text>const int intro_burst_length = </xsl:text><xsl:value-of select="count(remote/commandSet/command[position()=1]/raw/intro/flash)"/>
<xsl:text>;
const int repeat_burst_length = </xsl:text><xsl:value-of select="count(remote/commandSet/command[position()=1]/raw/repeat/flash)"/>
<xsl:text>;
const int ending_burst_length = </xsl:text><xsl:value-of select="count(remote/commandSet/command[position()=1]/raw/ending/flash)"/>
<xsl:text>;

</xsl:text>
        <xsl:apply-templates select="//command" mode="ccf"/>

        <xsl:apply-templates select="//command" mode="raw"/>
    </xsl:template>

    <xsl:template match="command" mode="ccf">
<xsl:text>/* Signal D = </xsl:text>
        <xsl:value-of select="parameters/parameter[@name='D']/@value"/>
        <xsl:text>; S = </xsl:text>
        <xsl:value-of select="parameters/parameter[@name='S']/@value"/>
        <xsl:text>; F = </xsl:text>
        <xsl:value-of select="parameters/parameter[@name='F']/@value"/>
        <xsl:text> */
const char *pronto_</xsl:text>
        <xsl:value-of select="parameters/@protocol"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="parameters/parameter[@name='D']/@value"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="parameters/parameter[@name='S']/@value"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="parameters/parameter[@name='F']/@value"/>
        <xsl:text> = "</xsl:text>
        <xsl:value-of select="ccf"/>
        <xsl:text>";
</xsl:text>
    </xsl:template>

    <xsl:template match="command" mode="raw">
       <xsl:text>const int raw_</xsl:text>
        <xsl:value-of select="parameters/@protocol"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="parameters/parameter[@name='D']/@value"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="parameters/parameter[@name='S']/@value"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="parameters/parameter[@name='F']/@value"/>
        <xsl:text>[] = { </xsl:text>
        <xsl:apply-templates select="raw"/>
        <xsl:text> };
</xsl:text>
    </xsl:template>

    <xsl:template match="raw">
        <xsl:apply-templates select="*/*"/>
    </xsl:template>

    <xsl:template match="flash"><xsl:value-of select="."/><xsl:text>,</xsl:text></xsl:template>

     <xsl:template match="raw/*[position()=last()]/gap[position()=last()]"><xsl:text>-</xsl:text><xsl:value-of select="."/></xsl:template>
     <xsl:template match="gap"><xsl:text>-</xsl:text><xsl:value-of select="."/><xsl:text>,</xsl:text></xsl:template>

</xsl:stylesheet>
</exportformat>

<exportformat name="Lintronic" extension="txt" multiSignal="false" simpleSequence="true">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <!--xsl:param name="noRepeats" select="4"/-->
    <xsl:output method="text" />

    <xsl:template match="/remotes">
        <xsl:text>Pulse, Pause in micro-seconds
</xsl:text>
<xsl:apply-templates select="remote[position()=1]/commandSet[position()=1]/command[position()=1]"/>
    </xsl:template>


    <xsl:template match="command">

        <xsl:apply-templates select="raw"/>
    </xsl:template>

    <xsl:template match="raw">
        <xsl:apply-templates select="intro/*"/>
        <xsl:call-template name="repeat"/>
        <xsl:apply-templates select="ending/*"/>
    </xsl:template>

    <xsl:template name="repeat">
         <xsl:param name="n" select="number($noRepeats)"/>
         <xsl:if test="not($n = 1)">
             <xsl:call-template name="repeat">
                 <xsl:with-param name="n" select="$n - 1"/>
             </xsl:call-template>
         </xsl:if>
         <xsl:apply-templates select="repeat/*"/>
    </xsl:template>

    <xsl:template match="flash"><xsl:value-of select='format-number(number(.),"00000")'/><xsl:text>,</xsl:text></xsl:template>
     <xsl:template match="gap"><xsl:text></xsl:text><xsl:value-of select='format-number(number(.),"00000")'/><xsl:text> = </xsl:text><xsl:value-of select='format-number(number(.)+number(preceding-sibling::flash[1]), "00000")'/><xsl:text>
</xsl:text></xsl:template>

</xsl:stylesheet>
</exportformat>


<exportformat name="IRTrans" extension="rem" multiSignal="true" simpleSequence="false">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />

    <xsl:template match="/remotes/remote[position()=1]">
        <xsl:text>[REMOTE]
 [NAME]ccf_</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>

[COMMANDS]
</xsl:text>
        <xsl:apply-templates select="commandSet/command"/>
    </xsl:template>

    <xsl:template match="command">
      <xsl:text> [</xsl:text>
      <xsl:value-of select="@name"/>
      <xsl:text>][CCF]</xsl:text>
      <xsl:value-of select="ccf"/>
      <xsl:text>
</xsl:text>
    </xsl:template>

</xsl:stylesheet>
</exportformat>

<exportformat name="TV B Gone" extension="c" multiSignal="false" simpleSequence="false">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />

    <xsl:template match="/remotes/remote[position()=1]/commandSet/command[position()=1]">
        <xsl:text>const struct powercode xCode PROGMEM = {
   freq_to_timerval(</xsl:text>
        <xsl:value-of select="raw/@frequency"/>
        <xsl:text>),
   {
</xsl:text>
        <xsl:apply-templates select="raw/*/*"/>
        <!--xsl:apply-templates select="command[position()=1]"/-->
        <xsl:text>   }
};
</xsl:text>
    </xsl:template>

    <xsl:template match="command">
    <xsl:apply-templates select="raw/*/*"/>
    </xsl:template>

    <xsl:template match="flash">
      <xsl:text>      { </xsl:text>
      <xsl:value-of select="round(number(.) div 10)"/>
      <xsl:text>, </xsl:text>
     </xsl:template>

    <xsl:template match="gap">
      <xsl:value-of select="round(number(.) div 10)"/>
      <xsl:text> },
</xsl:text>
     </xsl:template>

</xsl:stylesheet>
</exportformat>

<exportformat name="Spreadsheet" extension="tsv" multiSignal="true" simpleSequence="false">
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output method="text" />

        <xsl:template match="/">
            <xsl:apply-templates select="remotes/remote/commandSet/command"/>
        </xsl:template>

        <xsl:template match="command">
            <xsl:value-of select="@name"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="parameters/@protocol"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="parameters/parameter[@name='D']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="parameters/parameter[@name='S']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="parameters/parameter[@name='F']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="parameters/parameter[@name='T']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:apply-templates select="parameters/parameter[not(@name='F' or @name='D' or @name='S' or @name='T')]"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="raw/@frequency"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:apply-templates select="raw/intro/*"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:apply-templates select="raw/repeat/*"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:apply-templates select="raw/ending/*"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="ccf"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="@comment"/>
            <xsl:text>&#10;</xsl:text>
        </xsl:template>

        <xsl:template match="parameter">
            <xsl:value-of select="@name"/>
            <xsl:text>=</xsl:text>
            <xsl:value-of select="@value"/>
            <xsl:if test="position()!=last()">
                <xsl:text> </xsl:text>
            </xsl:if>
        </xsl:template>

        <xsl:template match="flash">
            <xsl:text>+</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text> </xsl:text>
        </xsl:template>
        <xsl:template match="gap">
            <xsl:text>-</xsl:text>
            <xsl:value-of select="."/>
            <xsl:if test="position()!=last()">
                <xsl:text> </xsl:text>
            </xsl:if>
        </xsl:template>

    </xsl:stylesheet>
</exportformat>

<exportformat name="RMFunctions" extension="tsv" multiSignal="true" simpleSequence="false">
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output method="text" />

        <xsl:template match="/">
            <xsl:apply-templates select="remotes/remote/commandSet/command"/>
        </xsl:template>

        <xsl:template match="command">
            <xsl:value-of select="@name"/>
            <xsl:text>&#9;</xsl:text> <!-- EFC -->
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="parameters/parameter[@name='F']/@value"/>
            <xsl:text>&#9;</xsl:text> <!-- Hex -->
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="@comment"/>
            <xsl:text>&#10;</xsl:text>
        </xsl:template>

    </xsl:stylesheet>
</exportformat>

<exportformat name="ICT" extension="ict" multiSignal="true" simpleSequence="false">
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output method="text" />

        <xsl:template match="/remotes">
            <xsl:text>irscope 0&#10;</xsl:text>
            <xsl:text>carrier_frequency </xsl:text>
            <xsl:value-of select="remote/commandSet/command/raw/@frequency"/>
            <xsl:text>&#10;</xsl:text>
            <xsl:text>sample_count </xsl:text>
            <xsl:value-of select="count(remote/commandSet/command/raw/*/*)"/>
            <xsl:text>&#10;</xsl:text>
            <xsl:apply-templates select="//command"/>
        </xsl:template>

        <xsl:template match="command">
            <xsl:text>note=</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>&#10;</xsl:text>
            <xsl:apply-templates select="*/*"/>
        </xsl:template>

        <xsl:template match="flash">
            <xsl:text>+</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>,</xsl:text>
            <xsl:value-of select="round(number(.) * number(../../@frequency div 1000000))"/>
            <xsl:text>&#10;</xsl:text>
        </xsl:template>

        <xsl:template match="gap">
            <xsl:text>-</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>&#10;</xsl:text>
        </xsl:template>

        <!-- There is a bug/design flaw in IrScope that makes it want to bundle all
        signals into one gigantic macro. Using brute force to circumvent... -->
        <xsl:template match="gap[position()=last()]">
            <xsl:text>-500000&#10;</xsl:text>
        </xsl:template>

    </xsl:stylesheet>
</exportformat>

<exportformat name="IrToy" extension="txt" multiSignal="false" simpleSequence="true">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <!--xsl:param name="noRepeats" select="4"/-->
    <xsl:param name="period" select="21.3333"/>
    <xsl:output method="text" />

    <xsl:template match="/remotes">
<xsl:apply-templates select="remote[position()=1]/commandSet[position()=1]/command[position()=1]"/>
    </xsl:template>

    <xsl:template match="command">
        <xsl:apply-templates select="raw"/>
    </xsl:template>

    <xsl:template match="raw">
        <xsl:apply-templates select="intro/*"/>
        <xsl:if test="$noRepeats > 0">
            <xsl:call-template name="repeat"/>
        </xsl:if>
        <xsl:apply-templates select="ending/*"/>
    </xsl:template>

    <xsl:template name="repeat">
         <xsl:param name="n" select="number($noRepeats)"/>
          <xsl:if test="not($n = 1)">
              <xsl:call-template name="repeat">
                 <xsl:with-param name="n" select="$n - 1"/>
             </xsl:call-template>
         </xsl:if>
         <xsl:apply-templates select="repeat/*"/>
    </xsl:template>

    <xsl:template match="gap|flash">
        <xsl:variable name="periods" select="floor(number(.) div $period)"/>
    <xsl:call-template name="hexnum">
        <xsl:with-param name="value" select="floor($periods div 256)"/>
    </xsl:call-template>
    <xsl:call-template name="hexnum">
        <xsl:with-param name="value" select="$periods mod 256"/>
    </xsl:call-template>
    </xsl:template>

    <xsl:template name="hexnum">
        <xsl:param name="value"/>
        <xsl:call-template name="hexdigit">
            <xsl:with-param name="val" select="floor($value div 16)"/>
        </xsl:call-template>
        <xsl:call-template name="hexdigit">
            <xsl:with-param name="val" select="$value mod 16"/>
        </xsl:call-template>
        <xsl:text> </xsl:text>
    </xsl:template>

    <xsl:template name="hexdigit">
        <xsl:param name="val"/>
           <xsl:value-of select="substring('0123456789ABCDEF',$val+1,1)"/>
        </xsl:template>
</xsl:stylesheet>
</exportformat>

<exportformat name="IrToy-bin" binary="true" extension="bin" multiSignal="false" simpleSequence="true">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <!--xsl:param name="noRepeats" select="2"/-->
    <xsl:param name="period" select="21.3333"/>
    <xsl:output method="xml"/>

    <xsl:template match="/remotes">
        <xsl:text>
</xsl:text>
        <binary>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="remote[position()=1]/commandSet[position()=1]/command[position()=1]"/>
        </binary>
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="command">
        <xsl:apply-templates select="raw"/>
    </xsl:template>

    <xsl:template match="raw">
        <xsl:apply-templates select="intro/*"/>
        <xsl:if test="$noRepeats > 0">
        <xsl:call-template name="repeat"/>
        </xsl:if>
        <xsl:apply-templates select="ending/*"/>
    </xsl:template>

    <xsl:template name="repeat">
         <xsl:param name="n" select="number($noRepeats)"/>
         <xsl:if test="not($n = 1)">
             <xsl:call-template name="repeat">
                 <xsl:with-param name="n" select="$n - 1"/>
             </xsl:call-template>
         </xsl:if>
         <xsl:apply-templates select="repeat/*"/>
    </xsl:template>

    <xsl:template match="gap|flash">
        <xsl:variable name="periods" select="floor(number(.) div $period)"/>
    <xsl:call-template name="hexnum">
        <xsl:with-param name="value" select="floor($periods div 256)"/>
    </xsl:call-template>
    <xsl:call-template name="hexnum">
        <xsl:with-param name="value" select="$periods mod 256"/>
    </xsl:call-template>
    </xsl:template>

    <xsl:template name="hexnum">
        <xsl:param name="value"/>
        <byte>
            <xsl:value-of select="$value"/>
        </byte>
        <xsl:text>
</xsl:text>
    </xsl:template>
</xsl:stylesheet>
</exportformat>

<exportformat name="mode2" extension="mode2" multiSignal="false" simpleSequence="true">
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <!--xsl:param name="noRepeats" select="4"/-->
        <xsl:output method="text" />

        <xsl:template match="/remotes">
            <xsl:apply-templates select="remote[position()=1]/commandSet[position()=1]/command[position()=1]"/>
        </xsl:template>

        <xsl:template match="command">
            <xsl:apply-templates select="raw"/>
        </xsl:template>

        <xsl:template match="raw">
            <xsl:apply-templates select="intro/*"/>
            <xsl:call-template name="repeat"/>
            <xsl:apply-templates select="ending/*"/>
        </xsl:template>

        <xsl:template name="repeat">
            <xsl:param name="n" select="number($noRepeats)"/>
            <xsl:if test="not($n = 1)">
                <xsl:call-template name="repeat">
                    <xsl:with-param name="n" select="$n - 1"/>
                </xsl:call-template>
            </xsl:if>
            <xsl:apply-templates select="repeat/*"/>
        </xsl:template>

        <xsl:template match="flash">
            <xsl:text>pulse </xsl:text>
            <xsl:value-of select='.'/>
            <xsl:text>
</xsl:text>
        </xsl:template>
        <xsl:template match="gap">
            <xsl:text>space </xsl:text>
            <xsl:value-of select='.'/>
            <xsl:text>
</xsl:text>
        </xsl:template>

    </xsl:stylesheet>
</exportformat>

<exportformat name="AnyMote" extension="amsr" multiSignal="true" simpleSequence="false">
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output method="text" />
        <xsl:strip-space elements="*" />

        <xsl:template match="remote[position()=1]">
            <xsl:text>{"name":"</xsl:text>
            <xsl:value-of select="@remoteName"/>
            <xsl:text>","all_codes":[</xsl:text>
            <xsl:apply-templates select="commandSet/command"/>
            <xsl:text>]}</xsl:text>
        </xsl:template>

        <xsl:template match="command">
            <xsl:text>{"function":"</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>","code1":"</xsl:text>
            <xsl:apply-templates select="raw"/>
            <xsl:text>"}</xsl:text>
            <xsl:if test="position()!=last()">
                <xsl:text>,</xsl:text>
            </xsl:if>
        </xsl:template>

        <xsl:template match="raw">
            <xsl:value-of select="@frequency"/>
            <xsl:text>,</xsl:text>
            <xsl:apply-templates select="node()/node()"/>
        </xsl:template>

        <xsl:template match="flash|gap">
            <xsl:value-of select="round(number(.) * number(../../@frequency) div 1000000)"/>
            <xsl:text>,</xsl:text>
        </xsl:template>

    </xsl:stylesheet>
</exportformat>



<!-- Here, additional export formats can be added if the user so desires.
Consider using XInclude for this, as in the following commented out code. -->

<xi:include href="myexportformats.xml">
    <xi:fallback/>
</xi:include>

</exportformats>
