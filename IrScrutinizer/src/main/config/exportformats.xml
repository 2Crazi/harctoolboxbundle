<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Copying and distribution of this file, with or without modification,
     are permitted in any medium without royalty provided the copyright
     notice and this notice are preserved.  This file is offered as-is,
     without any warranty.
-->

<!-- Note: This file not compatible with IrMaster! -->

<!--

Author: Bengt Martensson

-->
<exportformats>

<exportformat name="RemoteMaster" extension="rmdu" multiSignal="true" simpleSequence="false">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />

    <xsl:template match="/">
        <xsl:apply-templates select="remotes/remote[position()=1]"/> <!-- just consider the first remote -->
    </xsl:template>

    <xsl:template match="remote">
        <xsl:text># This file was created by IrScrutinizer.
# It is not directly usable in RemoteMaster. For this, make sure that
# protocols.ini contains the "protocol" ImportOnly. Also, check
# Options -> "Allow preserve Control", and then select
# "Preserve: OBC and function parameters" on the "Setup" pane.
# Then open this file with RemoteMaster, and select a sensible executor
# (called protocol in RemoteMaster).
#
# Original protocol: </xsl:text>
        <xsl:value-of select="commandSet[position()=1]/command[position()=1]/parameters/@protocol"/>
        <xsl:text>
#
Description=</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
Notes=</xsl:text>
        <xsl:value-of select="@comment"/>
        <xsl:text>\n\nOriginal protocol: </xsl:text>
        <xsl:value-of select="commandSet[position()=1]/command[position()=1]/parameters/@protocol"/>
        <xsl:text>
Remote.name=URC-7781 One For All Digital 12
Remote.signature=11311131
DeviceType=Cable
DeviceIndex=3
SetupCode=1999
Protocol=99 99
Protocol.name=ImportOnly
ProtocolParms=</xsl:text>
        <xsl:value-of select="commandSet[position()=1]/command[position()=1]/parameters/parameter[@name='D']/@value"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="commandSet[position()=1]/command[position()=1]/parameters/parameter[@name='S']/@value"/>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="commandSet/command"/>
    </xsl:template>

    <xsl:template match="command">
        <xsl:text>Function.</xsl:text>
        <xsl:value-of select="position() - 1"/>
        <xsl:text>.name=</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
Function.</xsl:text>
        <xsl:value-of select="position() - 1"/>
        <xsl:text>.hex=</xsl:text>
        <!--xsl:variable name="junk">parameters/parameter[@name='F']/@value</xsl:variable>
        <xsl:value-of select="java:java.lang.Integer.toHexString(111)"/-->
        <xsl:call-template name="toHexString">
            <xsl:with-param name="x" select="parameters/parameter[@name='F']/@value"/>
        </xsl:call-template>
        <xsl:apply-templates select="@comment"/>
        <xsl:text>
</xsl:text>

    </xsl:template>

    <xsl:template match="@comment">
        <xsl:text>
Function.</xsl:text>
        <xsl:value-of select="count(../preceding-sibling::command)"/>
        <xsl:text>.notes=</xsl:text>
        <xsl:value-of select="."/>
    </xsl:template>

    <xsl:template name="hexDigitWith0">
        <xsl:param name="x" />
        <xsl:value-of select="substring('0123456789ABCDEF', $x + 1, 1)"/>
    </xsl:template>

    <xsl:template name="hexDigit">
        <xsl:param name="x" />
        <xsl:value-of select="substring(' 123456789ABCDEF', $x + 1, 1)"/>
    </xsl:template>

    <xsl:template  name="toHexString">
        <xsl:param name="x"/>
        <!--xsl:value-of select="$x"/-->
        <xsl:call-template name="hexDigit">
            <xsl:with-param name="x" select="floor($x div 256)" />
        </xsl:call-template>
        <xsl:call-template name="hexDigitWith0">
            <xsl:with-param name="x" select="floor($x div 16) mod 16" />
        </xsl:call-template>
        <xsl:call-template name="hexDigitWith0">
            <xsl:with-param name="x" select="$x mod 16"/>
        </xsl:call-template>
    </xsl:template>
</xsl:stylesheet>
</exportformat>

<exportformat name="Arduino Raw" extension="ino" multiSignal="true" simpleSequence="false">
<!-- Limitations:supports only one remote (ignores all but the first one),
     Does not support ending sequences (ignores them). -->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />
    <xsl:variable name="ascii"> !&quot;#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</xsl:variable>
    <xsl:variable name="subst">________________0123456789_______ABCDEFGHIJKLMNOPQRSTUVWXYZ______abcdefghijklmnopqrstuvwxyz____</xsl:variable>

    <xsl:template match="/">
        <xsl:text><![CDATA[// This Arduino sketch was automatically generated by IrScrutinizer.

// It supports:
//
// * IRremote https://github.com/z3t0/Arduino-IRremote
//            http://z3t0.github.io/Arduino-IRremote/
// * IRLib    https://github.com/cyborg5/IRLib
// * Infrared4Arduino https://github.com/bengtmartensson/Infrared4Arduino,
//                    http://www.harctoolbox.org/Infrared4Arduino.html (planned)

// For problems, bugs, and suggestions, please open an issue at
// https://github.com/bengtmartensson/harctoolboxbundle/issues

// Define exactly one of these
// #define IRREMOTE
// #define IRLIB
#define INFRARED4ARDUINO

/////////////////////////////////////////////////////
// Sanity check
#if defined(IRREMOTE) & ( defined(IRLIB) | defined(INFRARED4ARDUINO) )
#error Must define only one of IRREMOTE, IRLIB, or INFRARED4ARDUINO
#endif

#if defined(IRLIB) & ( defined(IRREMOTE) | defined(INFRARED4ARDUINO) )
#error Must define only one of IRREMOTE, IRLIB, or INFRARED4ARDUINO
#endif

#if defined(INFRARED4ARDUINO) & ( defined(IRLIB) | defined(IRREMOTE) )
#error Must define only one of IRREMOTE, IRLIB, or INFRARED4ARDUINO
#endif

#ifdef IRREMOTE
#include <IRremote.h>
#elif defined(IRLIB)
#include <IRLib.h>
#define sendRaw send
#elif defined(INFRARED4ARDUINO)
#include <IrSenderPwm.h>
#else
#error Must defined one of IRREMOTE, IRLIB, or INFRARED4ARDUINO
#endif

#if defined(IRREMOTE) | defined(IRLIB)
typedef uint16_t microseconds_t; // Change if desired
typedef uint16_t frequency_t;    // Change if desired

static inline unsigned hz2khz(frequency_t f) { return f/1000; }
#endif

// Constants
static const long BAUD=115200;

// Global variables
#ifdef IRREMOTE
IRsend irsend;
#elif defined(IRLIB)
IRsendRaw irsend;
#else
IrSender *irsend = IrSenderPwm::getInstance(true);
#endif


]]></xsl:text>
<xsl:apply-templates select="remotes/remote[position()=1]//command" mode="definition"/>

<xsl:text><![CDATA[
static void sendRaw(const microseconds_t intro_P[], size_t lengthIntro, const microseconds_t repeat_P[],
             size_t lengthRepeat, frequency_t frequency, unsigned times) {
    microseconds_t intro[lengthIntro];
    microseconds_t repeat[lengthRepeat];
    memcpy_PF(intro, (uint_farptr_t) intro_P, sizeof(microseconds_t) * lengthIntro);
    memcpy_PF(repeat, (uint_farptr_t) repeat_P, sizeof(microseconds_t) * lengthRepeat);

#if defined(IRREMOTE) | defined(IRLIB)
    if (lengthIntro > 0)
        irsend.sendRaw(intro, lengthIntro, hz2khz(frequency));
    if (lengthRepeat > 0)
        for (unsigned i = 0; i < times - (lengthIntro > 0); i++)
            irsend.sendRaw(repeat, lengthRepeat, hz2khz(frequency));
#else // INFRARED4ARDUINO
    IrSignal irSignal(intro, lengthIntro, repeat, lengthRepeat, NULL, 0, frequency);
    irsend->sendIrSignal(irSignal, times);
#endif
}

void setup() {
    Serial.begin(BAUD);
    Serial.setTimeout(60000L);
}

// A pretty silly main loop; intended to serve as an example.
void loop() {
    Serial.println(F("Enter number of signal to send (1 .. ]]></xsl:text>
    <xsl:value-of select="count(//remote[position()=1]//command)"/>
    <xsl:text>)"));
    long commandno = Serial.parseInt();
    Serial.println(F("Enter number of times to send it"));
    long times = Serial.parseInt();
    switch (commandno) {
</xsl:text>
        <xsl:apply-templates select="//remote[position()=1]" mode="using"/>
        <xsl:text>    default:
        Serial.println("Invalid number entered, try again");
        break;
    }
}
</xsl:text>
    </xsl:template>

    <xsl:template match="remote" mode="using">
        <xsl:apply-templates select="//command" mode="using"/>
    </xsl:template>

    <xsl:template match="command" mode="definition">
        <xsl:text>// Command #</xsl:text>
        <xsl:value-of select="position()"/>
        <xsl:text>: </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="parameters"/>
        <xsl:apply-templates select="raw" mode="definition"/>
        <!--xsl:apply-templates select="ccf"/-->
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="ccf">
        <xsl:text>const char *pronto_</xsl:text>
        <xsl:value-of select="../@name"/>
        <xsl:text> = "</xsl:text>
        <xsl:value-of select="."/>
        <xsl:text>";
</xsl:text>
    </xsl:template>

    <xsl:template match="parameters">
        <xsl:text>// Protocol: </xsl:text>
        <xsl:value-of select="@protocol"/>
        <xsl:text>, Parameters:</xsl:text>
        <xsl:apply-templates select="parameter"/>
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="parameter">
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>=</xsl:text>
        <xsl:value-of select="@value"/>
    </xsl:template>

    <xsl:template match="raw" mode="definition">
        <xsl:apply-templates select="*" mode="definition"/>
    </xsl:template>

    <xsl:template match="intro|repeat" mode="definition">
        <xsl:text>const microseconds_t </xsl:text>
        <xsl:value-of select="name(.)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="translate(../../@name,$ascii,$subst)"/>
        <xsl:text>[] PROGMEM = { </xsl:text>
        <xsl:apply-templates select="*"/>
        <xsl:text> };
</xsl:text>
    </xsl:template>

    <xsl:template match="flash"><xsl:value-of select="."/><xsl:text>, </xsl:text></xsl:template>
     <xsl:template match="gap"><xsl:value-of select="."/><xsl:text>, </xsl:text></xsl:template>
     <xsl:template match="gap[position()=last()]">
         <xsl:if test=". &gt; 65535">
             <xsl:text>65535</xsl:text>
         </xsl:if>
         <xsl:if test=". &lt;= 65535">
             <xsl:value-of select="."/>
         </xsl:if>
     </xsl:template>

     <xsl:template match="command" mode="using">
         <xsl:text>    case </xsl:text>
         <xsl:value-of select="position()"/>
         <xsl:text>L:
</xsl:text>
     <xsl:text>        sendRaw(</xsl:text>
         <xsl:apply-templates select="raw" mode="arg"/>
         <xsl:value-of select="raw/@frequency"/>
         <xsl:text>, times);
        break;
</xsl:text>
     </xsl:template>

     <xsl:template match="raw" mode="arg">
         <xsl:if test="not(intro)">
             <xsl:text>NULL, 0, </xsl:text>
         </xsl:if>
         <xsl:apply-templates select="*" mode="arg"/>
         <xsl:if test="not(repeat)">
             <xsl:text>NULL, 0, </xsl:text>
         </xsl:if>
     </xsl:template>

     <xsl:template match="intro|repeat" mode="arg">
         <xsl:value-of select="name(.)"/>
         <xsl:text>_</xsl:text>
         <xsl:value-of select="translate(../../@name,$ascii,$subst)"/>
         <xsl:text>, </xsl:text>
         <xsl:value-of select="count(*)"/>
         <xsl:text>, </xsl:text>
     </xsl:template>

     <!-- just to be on the safe side -->
     <xsl:template match="ending">
         <xsl:comment>Warning: ending sequence in command <xsl:value-of select="../../@name"/> was ignored.</xsl:comment>
     </xsl:template>

</xsl:stylesheet>
</exportformat>

<exportformat name="C" extension="c" multiSignal="true" simpleSequence="false">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />

    <xsl:template match="/remotes">
        <xsl:text>/* This file was automatically generated by irpxml2c.xsl */

const int frequency = </xsl:text>
<xsl:value-of select="remote/commandSet/command/raw/@frequency"/><xsl:text>;
</xsl:text>
<xsl:text>const char *protocol = "</xsl:text><xsl:value-of select="remote/commandSet/command/parameters/@protocol"/><xsl:text>";
</xsl:text>
<xsl:text>const int intro_burst_length = </xsl:text><xsl:value-of select="count(remote/commandSet/command[position()=1]/raw/intro/flash)"/>
<xsl:text>;
const int repeat_burst_length = </xsl:text><xsl:value-of select="count(remote/commandSet/command[position()=1]/raw/repeat/flash)"/>
<xsl:text>;
const int ending_burst_length = </xsl:text><xsl:value-of select="count(remote/commandSet/command[position()=1]/raw/ending/flash)"/>
<xsl:text>;

</xsl:text>
        <xsl:apply-templates select="//command" mode="ccf"/>

        <xsl:apply-templates select="//command" mode="raw"/>
    </xsl:template>

    <xsl:template match="command" mode="ccf">
<xsl:text>/* Signal D = </xsl:text>
        <xsl:value-of select="parameters/parameter[@name='D']/@value"/>
        <xsl:text>; S = </xsl:text>
        <xsl:value-of select="parameters/parameter[@name='S']/@value"/>
        <xsl:text>; F = </xsl:text>
        <xsl:value-of select="parameters/parameter[@name='F']/@value"/>
        <xsl:text> */
const char *pronto_</xsl:text>
        <xsl:value-of select="parameters/@protocol"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="parameters/parameter[@name='D']/@value"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="parameters/parameter[@name='S']/@value"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="parameters/parameter[@name='F']/@value"/>
        <xsl:text> = "</xsl:text>
        <xsl:value-of select="ccf"/>
        <xsl:text>";
</xsl:text>
    </xsl:template>

    <xsl:template match="command" mode="raw">
       <xsl:text>const int raw_</xsl:text>
        <xsl:value-of select="parameters/@protocol"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="parameters/parameter[@name='D']/@value"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="parameters/parameter[@name='S']/@value"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="parameters/parameter[@name='F']/@value"/>
        <xsl:text>[] = { </xsl:text>
        <xsl:apply-templates select="raw"/>
        <xsl:text> };
</xsl:text>
    </xsl:template>

    <xsl:template match="raw">
        <xsl:apply-templates select="*/*"/>
    </xsl:template>

    <xsl:template match="flash"><xsl:value-of select="."/><xsl:text>,</xsl:text></xsl:template>

     <xsl:template match="raw/*[position()=last()]/gap[position()=last()]"><xsl:text>-</xsl:text><xsl:value-of select="."/></xsl:template>
     <xsl:template match="gap"><xsl:text>-</xsl:text><xsl:value-of select="."/><xsl:text>,</xsl:text></xsl:template>

</xsl:stylesheet>
</exportformat>

<exportformat name="Lintronic" extension="txt" multiSignal="false" simpleSequence="true">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <!--xsl:param name="noRepeats" select="4"/-->
    <xsl:output method="text" />

    <xsl:template match="/remotes">
        <xsl:text>Pulse, Pause in micro-seconds
</xsl:text>
<xsl:apply-templates select="remote[position()=1]/commandSet[position()=1]/command[position()=1]"/>
    </xsl:template>


    <xsl:template match="command">

        <xsl:apply-templates select="raw"/>
    </xsl:template>

    <xsl:template match="raw">
        <xsl:apply-templates select="intro/*"/>
        <xsl:call-template name="repeat"/>
        <xsl:apply-templates select="ending/*"/>
    </xsl:template>

    <xsl:template name="repeat">
         <xsl:param name="n" select="number($noRepeats)"/>
         <xsl:if test="not($n = 1)">
             <xsl:call-template name="repeat">
                 <xsl:with-param name="n" select="$n - 1"/>
             </xsl:call-template>
         </xsl:if>
         <xsl:apply-templates select="repeat/*"/>
    </xsl:template>

    <xsl:template match="flash"><xsl:value-of select='format-number(number(.),"00000")'/><xsl:text>,</xsl:text></xsl:template>
     <xsl:template match="gap"><xsl:text></xsl:text><xsl:value-of select='format-number(number(.),"00000")'/><xsl:text> = </xsl:text><xsl:value-of select='format-number(number(.)+number(preceding-sibling::flash[1]), "00000")'/><xsl:text>
</xsl:text></xsl:template>

</xsl:stylesheet>
</exportformat>


<exportformat name="IRTrans" extension="rem" multiSignal="true" simpleSequence="false">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />

    <xsl:template match="/remotes/remote[position()=1]">
        <xsl:text>[REMOTE]
 [NAME]ccf_</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>

[COMMANDS]
</xsl:text>
        <xsl:apply-templates select="commandSet/command"/>
    </xsl:template>

    <xsl:template match="command">
      <xsl:text> [</xsl:text>
      <xsl:value-of select="@name"/>
      <xsl:text>][CCF]</xsl:text>
      <xsl:value-of select="ccf"/>
      <xsl:text>
</xsl:text>
    </xsl:template>

</xsl:stylesheet>
</exportformat>

<exportformat name="TV B Gone" extension="c" multiSignal="false" simpleSequence="false">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" />

    <xsl:template match="/remotes/remote[position()=1]/commandSet/command[position()=1]">
        <xsl:text>const struct powercode xCode PROGMEM = {
   freq_to_timerval(</xsl:text>
        <xsl:value-of select="raw/@frequency"/>
        <xsl:text>),
   {
</xsl:text>
        <xsl:apply-templates select="raw/*/*"/>
        <!--xsl:apply-templates select="command[position()=1]"/-->
        <xsl:text>   }
};
</xsl:text>
    </xsl:template>

    <xsl:template match="command">
    <xsl:apply-templates select="raw/*/*"/>
    </xsl:template>

    <xsl:template match="flash">
      <xsl:text>      { </xsl:text>
      <xsl:value-of select="round(number(.) div 10)"/>
      <xsl:text>, </xsl:text>
     </xsl:template>

    <xsl:template match="gap">
      <xsl:value-of select="round(number(.) div 10)"/>
      <xsl:text> },
</xsl:text>
     </xsl:template>

</xsl:stylesheet>
</exportformat>

<exportformat name="Spreadsheet" extension="tsv" multiSignal="true" simpleSequence="false">
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output method="text" />

        <xsl:template match="/">
            <xsl:apply-templates select="remotes/remote/commandSet/command"/>
        </xsl:template>

        <xsl:template match="command">
            <xsl:value-of select="@name"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="parameters/@protocol"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="parameters/parameter[@name='D']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="parameters/parameter[@name='S']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="parameters/parameter[@name='F']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="parameters/parameter[@name='T']/@value"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:apply-templates select="parameters/parameter[not(@name='F' or @name='D' or @name='S' or @name='T')]"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="raw/@frequency"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:apply-templates select="raw/intro/*"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:apply-templates select="raw/repeat/*"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:apply-templates select="raw/ending/*"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="ccf"/>
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="@comment"/>
            <xsl:text>&#10;</xsl:text>
        </xsl:template>

        <xsl:template match="parameter">
            <xsl:value-of select="@name"/>
            <xsl:text>=</xsl:text>
            <xsl:value-of select="@value"/>
            <xsl:if test="position()!=last()">
                <xsl:text> </xsl:text>
            </xsl:if>
        </xsl:template>

        <xsl:template match="flash">
            <xsl:text>+</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text> </xsl:text>
        </xsl:template>
        <xsl:template match="gap">
            <xsl:text>-</xsl:text>
            <xsl:value-of select="."/>
            <xsl:if test="position()!=last()">
                <xsl:text> </xsl:text>
            </xsl:if>
        </xsl:template>

    </xsl:stylesheet>
</exportformat>

<exportformat name="RMFunctions" extension="tsv" multiSignal="true" simpleSequence="false">
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output method="text" />

        <xsl:template match="/">
            <xsl:apply-templates select="remotes/remote/commandSet/command"/>
        </xsl:template>

        <xsl:template match="command">
            <xsl:value-of select="@name"/>
            <xsl:text>&#9;</xsl:text> <!-- EFC -->
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="parameters/parameter[@name='F']/@value"/>
            <xsl:text>&#9;</xsl:text> <!-- Hex -->
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="@comment"/>
            <xsl:text>&#10;</xsl:text>
        </xsl:template>

    </xsl:stylesheet>
</exportformat>

<exportformat name="ICT" extension="ict" multiSignal="true" simpleSequence="false">
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output method="text" />

        <xsl:template match="/remotes">
            <xsl:text>irscope 0&#10;</xsl:text>
            <xsl:text>carrier_frequency </xsl:text>
            <xsl:value-of select="remote/commandSet/command/raw/@frequency"/>
            <xsl:text>&#10;</xsl:text>
            <xsl:text>sample_count </xsl:text>
            <xsl:value-of select="count(remote/commandSet/command/raw/*/*)"/>
            <xsl:text>&#10;</xsl:text>
            <xsl:apply-templates select="//command"/>
        </xsl:template>

        <xsl:template match="command">
            <xsl:text>note=</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>&#10;</xsl:text>
            <xsl:apply-templates select="*/*"/>
        </xsl:template>

        <xsl:template match="flash">
            <xsl:text>+</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>,</xsl:text>
            <xsl:value-of select="round(number(.) * number(../../@frequency div 1000000))"/>
            <xsl:text>&#10;</xsl:text>
        </xsl:template>

        <xsl:template match="gap">
            <xsl:text>-</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>&#10;</xsl:text>
        </xsl:template>

        <!-- There is a bug/design flaw in IrScope that makes it want to bundle all
        signals into one gigantic macro. Using brute force to circumvent... -->
        <xsl:template match="gap[position()=last()]">
            <xsl:text>-500000&#10;</xsl:text>
        </xsl:template>

    </xsl:stylesheet>
</exportformat>

<exportformat name="IrToy" extension="txt" multiSignal="false" simpleSequence="true">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <!--xsl:param name="noRepeats" select="4"/-->
    <xsl:param name="period" select="21.3333"/>
    <xsl:output method="text" />

    <xsl:template match="/remotes">
<xsl:apply-templates select="remote[position()=1]/commandSet[position()=1]/command[position()=1]"/>
    </xsl:template>

    <xsl:template match="command">
        <xsl:apply-templates select="raw"/>
    </xsl:template>

    <xsl:template match="raw">
        <xsl:apply-templates select="intro/*"/>
        <xsl:if test="$noRepeats > 0">
            <xsl:call-template name="repeat"/>
        </xsl:if>
        <xsl:apply-templates select="ending/*"/>
    </xsl:template>

    <xsl:template name="repeat">
         <xsl:param name="n" select="number($noRepeats)"/>
          <xsl:if test="not($n = 1)">
              <xsl:call-template name="repeat">
                 <xsl:with-param name="n" select="$n - 1"/>
             </xsl:call-template>
         </xsl:if>
         <xsl:apply-templates select="repeat/*"/>
    </xsl:template>

    <xsl:template match="gap|flash">
        <xsl:variable name="periods" select="floor(number(.) div $period)"/>
    <xsl:call-template name="hexnum">
        <xsl:with-param name="value" select="floor($periods div 256)"/>
    </xsl:call-template>
    <xsl:call-template name="hexnum">
        <xsl:with-param name="value" select="$periods mod 256"/>
    </xsl:call-template>
    </xsl:template>

    <xsl:template name="hexnum">
        <xsl:param name="value"/>
        <xsl:call-template name="hexdigit">
            <xsl:with-param name="val" select="floor($value div 16)"/>
        </xsl:call-template>
        <xsl:call-template name="hexdigit">
            <xsl:with-param name="val" select="$value mod 16"/>
        </xsl:call-template>
        <xsl:text> </xsl:text>
    </xsl:template>

    <xsl:template name="hexdigit">
        <xsl:param name="val"/>
           <xsl:value-of select="substring('0123456789ABCDEF',$val+1,1)"/>
        </xsl:template>
</xsl:stylesheet>
</exportformat>

<exportformat name="IrToy-bin" binary="true" extension="bin" multiSignal="false" simpleSequence="true">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <!--xsl:param name="noRepeats" select="2"/-->
    <xsl:param name="period" select="21.3333"/>
    <xsl:output method="xml"/>

    <xsl:template match="/remotes">
        <xsl:text>
</xsl:text>
        <binary>
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="remote[position()=1]/commandSet[position()=1]/command[position()=1]"/>
        </binary>
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="command">
        <xsl:apply-templates select="raw"/>
    </xsl:template>

    <xsl:template match="raw">
        <xsl:apply-templates select="intro/*"/>
        <xsl:if test="$noRepeats > 0">
        <xsl:call-template name="repeat"/>
        </xsl:if>
        <xsl:apply-templates select="ending/*"/>
    </xsl:template>

    <xsl:template name="repeat">
         <xsl:param name="n" select="number($noRepeats)"/>
         <xsl:if test="not($n = 1)">
             <xsl:call-template name="repeat">
                 <xsl:with-param name="n" select="$n - 1"/>
             </xsl:call-template>
         </xsl:if>
         <xsl:apply-templates select="repeat/*"/>
    </xsl:template>

    <xsl:template match="gap|flash">
        <xsl:variable name="periods" select="floor(number(.) div $period)"/>
    <xsl:call-template name="hexnum">
        <xsl:with-param name="value" select="floor($periods div 256)"/>
    </xsl:call-template>
    <xsl:call-template name="hexnum">
        <xsl:with-param name="value" select="$periods mod 256"/>
    </xsl:call-template>
    </xsl:template>

    <xsl:template name="hexnum">
        <xsl:param name="value"/>
        <byte>
            <xsl:value-of select="$value"/>
        </byte>
        <xsl:text>
</xsl:text>
    </xsl:template>
</xsl:stylesheet>
</exportformat>

<exportformat name="mode2" extension="mode2" multiSignal="false" simpleSequence="true">
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <!--xsl:param name="noRepeats" select="4"/-->
        <xsl:output method="text" />

        <xsl:template match="/remotes">
            <xsl:apply-templates select="remote[position()=1]/commandSet[position()=1]/command[position()=1]"/>
        </xsl:template>

        <xsl:template match="command">
            <xsl:apply-templates select="raw"/>
        </xsl:template>

        <xsl:template match="raw">
            <xsl:apply-templates select="intro/*"/>
            <xsl:call-template name="repeat"/>
            <xsl:apply-templates select="ending/*"/>
        </xsl:template>

        <xsl:template name="repeat">
            <xsl:param name="n" select="number($noRepeats)"/>
            <xsl:if test="not($n = 1)">
                <xsl:call-template name="repeat">
                    <xsl:with-param name="n" select="$n - 1"/>
                </xsl:call-template>
            </xsl:if>
            <xsl:apply-templates select="repeat/*"/>
        </xsl:template>

        <xsl:template match="flash">
            <xsl:text>pulse </xsl:text>
            <xsl:value-of select='.'/>
            <xsl:text>
</xsl:text>
        </xsl:template>
        <xsl:template match="gap">
            <xsl:text>space </xsl:text>
            <xsl:value-of select='.'/>
            <xsl:text>
</xsl:text>
        </xsl:template>

    </xsl:stylesheet>
</exportformat>

<exportformat name="AnyMote" extension="amsr" multiSignal="true" simpleSequence="false">
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output method="text" />
        <xsl:strip-space elements="*" />

        <xsl:template match="remote[position()=1]">
            <xsl:text>{"name":"</xsl:text>
            <xsl:value-of select="@remoteName"/>
            <xsl:text>","all_codes":[</xsl:text>
            <xsl:apply-templates select="commandSet/command"/>
            <xsl:text>]}</xsl:text>
        </xsl:template>

        <xsl:template match="command">
            <xsl:text>{"function":"</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>","code1":"</xsl:text>
            <xsl:apply-templates select="raw"/>
            <xsl:text>"}</xsl:text>
            <xsl:if test="position()!=last()">
                <xsl:text>,</xsl:text>
            </xsl:if>
        </xsl:template>

        <xsl:template match="raw">
            <xsl:value-of select="@frequency"/>
            <xsl:text>,</xsl:text>
            <xsl:apply-templates select="node()/node()"/>
        </xsl:template>

        <xsl:template match="flash|gap">
            <xsl:value-of select="round(number(.) * number(../../@frequency) div 1000000)"/>
            <xsl:text>,</xsl:text>
        </xsl:template>

    </xsl:stylesheet>
</exportformat>

<exportformat name="irplus" extension="irplus" multiSignal="true" simpleSequence="false">
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="xml" indent="yes" omit-xml-declaration="yes"/>

    <xsl:template match="/remotes">
        <irplus>
            <xsl:comment>This file was automatically generated by IrScrutinizer</xsl:comment>
            <xsl:apply-templates select="remote"/>
        </irplus>
    </xsl:template>

    <xsl:template match="remote">
        <device>
            <xsl:attribute name="manufacturer">
                <xsl:value-of select="@manufacturer"/>
                <xsl:if test="not(@manufacturer)">unknown manufacturer</xsl:if>
            </xsl:attribute>
            <xsl:attribute name="model">
                <xsl:value-of select="@model"/>
                <xsl:if test="not(@model)">unknown model</xsl:if>
            </xsl:attribute>
            <xsl:attribute name="format">PRONTO_HEX</xsl:attribute>
            <!--xsl:attribute name="columns">3</xsl:attribute--> <!-- uncomment if desired -->
            <xsl:apply-templates select="commandSet/command"/>
        </device>
    </xsl:template>

    <xsl:template match="command">
        <button>
            <xsl:attribute name="label">
                <xsl:value-of select="@name"/>
            </xsl:attribute>
            <xsl:value-of select="ccf"/>
        </button>
    </xsl:template>
</xsl:stylesheet>

</exportformat>

</exportformats>
